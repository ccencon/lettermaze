# lettermaze
play letter maze on your A4 paper.

前些天在玩迷宫游戏时突然回想起初中有段时间很喜欢画字母迷宫给同学们破解，具体做法是在草稿纸上用尺子画上一个巨大的矩形，再等分为许多的小方块，并在小方块上填充字母，借助复印纸复印几份，然后让同学们按照A-Z-A-Z...的顺序从入口到出口连接字母；由于事先会故意设置好几条深度比较大的歧路，在字母交错复杂的纸上，小伙伴们需要经历好些挫折，花费好些时间才能破解连出路径，想起来趣味性也是比较强的

为了怀念一下逝去的时光，于是乎便花费了一些时间写了这个小玩具。你可以使用这个玩具生成随机字母迷宫及其答案路径图片，并选择打印出来在纸上进行标注破解（入口为右上角，出口为左下角），这应该特别适合小孩子，或者几百个月大的小孩子`^_^`，复杂而有趣的求解过程不仅益智，还可以使其专注和耐心

下面的篇幅将会记录编码过程中遇到的问题，如果你对代码不感兴趣，只需执行编译脚本运行程序生成图片即可。整个程序可以简单划分为两个模块：字母矩阵、图片生成

##### 字母矩阵
按照以前手动设计字母矩阵的思路，总是会先填充出一条唯一正确的路径，然后再在此路径上的某些点引出一条歧路，并对此歧路递归以上操作；但如果将这个思路转化成代码，递归的终止条件将会变得不好设置，在手动设计时，都是凭个人感觉终止，而且按照这种方式，最终矩阵也极有可能存在还没被填充的方格，虽然可以事后再遍历一次，但明显不够优雅。或许多花一点时间研究也可以解决这个问题，但由于知道其它思路，潜意识里便把这种方法排除了

字母矩阵的生成可以借鉴迷宫的生成算法，它们本质是一样的；而常见的迷宫生成算法以`普里姆`和`克鲁斯卡尔`算法最为出名，这其实就是图论中[最小生成树](https://github.com/ccencon/structdata#DirectedGraph)的两种经典算法，生成边权重最小，且不形成环的图，使图中任意两点都可以连通。

`普里姆`在迷宫算法的具体思路为：

1. 选择一个起点，将起点四周的墙加入到列表L
2. 当列表L不为空时，重复执行以下步骤：
	1. 从L中随机弹出一面墙
	2. 如果墙两边存在未打通区域A，便打通这面墙，并将A附近未打通的墙加入到L（如果墙的另外一个区域已被打通，这个操作会使迷宫形成环；如果不想形成环，可以判断另外一个区域是否被打通，如果打通便不加入L了）

`克鲁斯卡尔`在迷宫算法的具体思路为：

1. 将迷宫所有墙加入到列表L中
2. 当列表L不为空时，重复执行以下步骤：
	1. 从L中随机弹出一面墙
	2. 借助并查集判断墙两边区域是否打通，还没通便打通这边墙

因为字母矩阵与迷宫在最终表达形式上存在差异，字母矩阵需要在路径上填充字母，所以从选定起点开始向外辐射路径的`普里姆`无疑是最佳选择，`克鲁斯卡尔`因为其特性，在执行过程中无法填充字母

但在实现字母矩阵的`普里姆`算法之后，出现了两个问题，第一个是由于在路径上填充了字母，使得原本不导通的两个区域通过字母顺序实现了导通，这样到终点的路径很有可能不再唯一；另一个问题是，由于普里姆算法是以起点为中心，向外面辐射，新加入的墙对墙列表的占比不大，在经历几次随机之后旧墙基本都会被选中，所以只需要沿着起点往终点直线附近的方向行走，大概率就能走到终点

为了解决这两个问题，需要对已经实现的`普里姆`算法进行优化，最终采用的方案是，先随机出起点到终点的唯一路径，并将路径上所有的墙加入到墙列表L中，并对此执行`普里姆`算法的计算；这样就从一个点的向外辐射变成了一条路径的向外辐射，随机性大大升高，而且由于事先知道了起点到终点的唯一路径，只要在此路径外填充的字母不会使其融入到此路径中，此路径就不会丢失唯一性

在对`普里姆`进行优化之后，又引出了另外一个问题，就是程序时不时卡死，在经历一系列蛋痛的调试之后，终于发现问题所在，
